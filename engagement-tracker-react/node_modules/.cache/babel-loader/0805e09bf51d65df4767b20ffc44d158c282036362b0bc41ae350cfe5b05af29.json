{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, buffer, GatherNd, util } from '@tensorflow/tfjs-core';\nexport function gatherNd(args) {\n  const {\n    inputs,\n    backend\n  } = args;\n  const {\n    params,\n    indices\n  } = inputs;\n  const paramsSize = util.sizeFromShape(params.shape);\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n  const [resultShape, numSlices, sliceSize, strides] = backend_util.prepareAndValidate(params, indices);\n  if (numSlices === 0) {\n    return backend.makeTensorInfo(resultShape, params.dtype, []);\n  }\n  const outBuf = buffer([numSlices, sliceSize], params.dtype);\n  const indicesData = backend.data.get(indices.dataId).values;\n  const paramsData = backend.data.get(params.dataId).values;\n  for (let i = 0; i < numSlices; i++) {\n    const index = [];\n    let flattenIndex = 0;\n    for (let j = 0; j < sliceRank; j++) {\n      const dim = indicesData[i * sliceRank + j];\n      flattenIndex += dim * strides[j];\n      index.push(dim);\n    }\n    if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {\n      throw new Error(\"Invalid indices: \".concat(index, \" does not index into \").concat(params.shape));\n    }\n    for (let k = 0; k < sliceSize; k++) {\n      outBuf.values[i * sliceSize + k] = paramsData[flattenIndex * sliceSize + k];\n    }\n  }\n  return backend.makeTensorInfo(resultShape, outBuf.dtype, outBuf.values);\n}\nexport const gatherNdConfig = {\n  kernelName: GatherNd,\n  backendName: 'cpu',\n  kernelFunc: gatherNd\n};","map":{"version":3,"names":["backend_util","buffer","GatherNd","util","gatherNd","args","inputs","backend","params","indices","paramsSize","sizeFromShape","shape","indicesShape","sliceRank","length","resultShape","numSlices","sliceSize","strides","prepareAndValidate","makeTensorInfo","dtype","outBuf","indicesData","data","get","dataId","values","paramsData","i","index","flattenIndex","j","dim","push","Error","concat","k","gatherNdConfig","kernelName","backendName","kernelFunc"],"sources":["C:\\Users\\reddy\\Documents\\Projects\\engagement-tracker-react\\node_modules\\@tensorflow\\tfjs-backend-cpu\\src\\kernels\\GatherNd.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, buffer, GatherNd, GatherNdInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function gatherNd(\n    args: {inputs: GatherNdInputs, backend: MathBackendCPU}): TensorInfo {\n  const {inputs, backend} = args;\n  const {params, indices} = inputs;\n\n  const paramsSize = util.sizeFromShape(params.shape);\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n\n  const [resultShape, numSlices, sliceSize, strides] =\n      backend_util.prepareAndValidate(params, indices);\n  if (numSlices === 0) {\n    return backend.makeTensorInfo(resultShape, params.dtype, []);\n  }\n\n  const outBuf = buffer([numSlices, sliceSize], params.dtype);\n  const indicesData = backend.data.get(indices.dataId).values as TypedArray;\n  const paramsData = backend.data.get(params.dataId).values as TypedArray;\n\n  for (let i = 0; i < numSlices; i++) {\n    const index = [];\n    let flattenIndex = 0;\n    for (let j = 0; j < sliceRank; j++) {\n      const dim = indicesData[i * sliceRank + j];\n      flattenIndex += dim * strides[j];\n      index.push(dim);\n    }\n    if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {\n      throw new Error(\n          `Invalid indices: ${index} does not index into ${params.shape}`);\n    }\n\n    for (let k = 0; k < sliceSize; k++) {\n      outBuf.values[i * sliceSize + k] =\n          paramsData[flattenIndex * sliceSize + k];\n    }\n  }\n\n  return backend.makeTensorInfo(resultShape, outBuf.dtype, outBuf.values);\n}\n\nexport const gatherNdConfig: KernelConfig = {\n  kernelName: GatherNd,\n  backendName: 'cpu',\n  kernelFunc: gatherNd as {} as KernelFunc\n};\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,YAAY,EAAEC,MAAM,EAAEC,QAAQ,EAAoEC,IAAI,QAAO,uBAAuB;AAI5I,OAAM,SAAUC,QAAQA,CACpBC,IAAuD;EACzD,MAAM;IAACC,MAAM;IAAEC;EAAO,CAAC,GAAGF,IAAI;EAC9B,MAAM;IAACG,MAAM;IAAEC;EAAO,CAAC,GAAGH,MAAM;EAEhC,MAAMI,UAAU,GAAGP,IAAI,CAACQ,aAAa,CAACH,MAAM,CAACI,KAAK,CAAC;EAEnD,MAAMC,YAAY,GAAGJ,OAAO,CAACG,KAAK;EAClC,MAAME,SAAS,GAAGD,YAAY,CAACA,YAAY,CAACE,MAAM,GAAG,CAAC,CAAC;EAEvD,MAAM,CAACC,WAAW,EAAEC,SAAS,EAAEC,SAAS,EAAEC,OAAO,CAAC,GAC9CnB,YAAY,CAACoB,kBAAkB,CAACZ,MAAM,EAAEC,OAAO,CAAC;EACpD,IAAIQ,SAAS,KAAK,CAAC,EAAE;IACnB,OAAOV,OAAO,CAACc,cAAc,CAACL,WAAW,EAAER,MAAM,CAACc,KAAK,EAAE,EAAE,CAAC;;EAG9D,MAAMC,MAAM,GAAGtB,MAAM,CAAC,CAACgB,SAAS,EAAEC,SAAS,CAAC,EAAEV,MAAM,CAACc,KAAK,CAAC;EAC3D,MAAME,WAAW,GAAGjB,OAAO,CAACkB,IAAI,CAACC,GAAG,CAACjB,OAAO,CAACkB,MAAM,CAAC,CAACC,MAAoB;EACzE,MAAMC,UAAU,GAAGtB,OAAO,CAACkB,IAAI,CAACC,GAAG,CAAClB,MAAM,CAACmB,MAAM,CAAC,CAACC,MAAoB;EAEvE,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,SAAS,EAAEa,CAAC,EAAE,EAAE;IAClC,MAAMC,KAAK,GAAG,EAAE;IAChB,IAAIC,YAAY,GAAG,CAAC;IACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,SAAS,EAAEmB,CAAC,EAAE,EAAE;MAClC,MAAMC,GAAG,GAAGV,WAAW,CAACM,CAAC,GAAGhB,SAAS,GAAGmB,CAAC,CAAC;MAC1CD,YAAY,IAAIE,GAAG,GAAGf,OAAO,CAACc,CAAC,CAAC;MAChCF,KAAK,CAACI,IAAI,CAACD,GAAG,CAAC;;IAEjB,IAAIF,YAAY,GAAG,CAAC,IAAIA,YAAY,IAAItB,UAAU,GAAGQ,SAAS,EAAE;MAC9D,MAAM,IAAIkB,KAAK,qBAAAC,MAAA,CACSN,KAAK,2BAAAM,MAAA,CAAwB7B,MAAM,CAACI,KAAK,CAAE,CAAC;;IAGtE,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,SAAS,EAAEoB,CAAC,EAAE,EAAE;MAClCf,MAAM,CAACK,MAAM,CAACE,CAAC,GAAGZ,SAAS,GAAGoB,CAAC,CAAC,GAC5BT,UAAU,CAACG,YAAY,GAAGd,SAAS,GAAGoB,CAAC,CAAC;;;EAIhD,OAAO/B,OAAO,CAACc,cAAc,CAACL,WAAW,EAAEO,MAAM,CAACD,KAAK,EAAEC,MAAM,CAACK,MAAM,CAAC;AACzE;AAEA,OAAO,MAAMW,cAAc,GAAiB;EAC1CC,UAAU,EAAEtC,QAAQ;EACpBuC,WAAW,EAAE,KAAK;EAClBC,UAAU,EAAEtC;CACb"},"metadata":{},"sourceType":"module","externalDependencies":[]}