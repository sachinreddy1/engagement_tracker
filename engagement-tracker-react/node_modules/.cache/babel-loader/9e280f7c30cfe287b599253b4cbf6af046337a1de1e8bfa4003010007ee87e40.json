{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport class DepthwiseConvPacked2DProgram {\n  constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n    this.variableNames = ['x', 'W'];\n    this.packedInputs = true;\n    this.packedOutput = true;\n    this.outputShape = convInfo.outShape;\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const texelsAcross = filterWidth;\n    let mainLoop = `int xR; int xC; int xCOffset;`;\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `\n          vec4 xTexelR${r}C${c * 2} = vec4(0.);\n          vec4 wR${r}C${c} = vec4(0.);\n          vec4 xR${r}C${c} = vec4(0.);`;\n      }\n    }\n    /**\n     * This vectorized implementation works by gathering the values needed for\n     * each output channel's dot product into vec4's and then multiplying them\n     * all together (this happens in the final double for-loop below). Most of\n     * the main loop consists of constructing these vec4's with the minimum\n     * number of texture2D calls, which means making use of all four returned\n     * values from a texture2D call at once.\n     */\n    for (let r = 0; r < filterHeight; r++) {\n      for (let texelC = 0; texelC < texelsAcross; texelC++) {\n        const c = texelC * 2;\n        mainLoop += `\n          xR = xRCorner + ${r * dilationHeight};\n          xC = xCCorner + ${c * dilationWidth};\n        `;\n        if (strideWidth === 1) {\n          if (c < filterWidth) {\n            // If padding is odd, the outer texels have to be composed.\n            if (padLeft % 2 === 1) {\n              // TODO: Ensure vec4 previous does not result in redundant sample,\n              // and avoid setting xTexelRC's that exceed the boundary in the\n              // first place rather than resetting them to vec4(0)).\n              // To compute xCOffset:\n              // - If padding is odd, we must add 1 to ensure we ask for an\n              // even-numbered row.\n              // - We subtract 2 to access the previous texel.\n              mainLoop += `\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    xTexelR${r}C${c}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);\n                } else {\n                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);\n                }\n              `;\n            } else {\n              // Padding is even, so xRC corresponds to a single texel.\n              mainLoop += `\n                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xR${r}C${c} = xTexelR${r}C${c};\n              `;\n            }\n            if (c + 1 < filterWidth) {\n              // If dilation is even, the second entry should match the first\n              // (either both are composed or both are single samples). But if\n              // dilation is odd, then the second entry should be the opposite\n              // of the first (if the first is composed, the second is a single\n              // sample, and vice versa.)\n              const nextTexelOffset = padLeft % 2 === 0 ? util.nearestLargerEven(dilationWidth) : dilationWidth;\n              if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {\n                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `;\n                // If dilation > 1 then the xRC's will not be able to share any\n                // values, so each xRC will require two unique calls to getX.\n                if (dilationWidth > 1) {\n                  mainLoop += `\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${xNumRows} &&\n                      xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${r}C${c} = vec4(0.);\n                    }\n                  `;\n                }\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);\n                `;\n              } else {\n                mainLoop += `\n                  xCOffset = xC + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};\n                `;\n              }\n            }\n          }\n        } else {\n          // stride > 1\n          if (c < filterWidth) {\n            mainLoop += `\n              if(xR >= 0 && xR < ${xNumRows}) {\n            `;\n            // Depending on whether padLeft is even or odd, we want either the\n            // xy or zw channels from X texels for xR${r}C${c}. If padLeft is\n            // even, xR${r}C${c + 1} is simply the zw channels of texels we've\n            // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will\n            // need to come from the xy channels of a new texel, hence the `vec4\n            // final` initialized below.\n            if (padLeft % 2 === 1) {\n              mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n              `;\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);\n                `;\n              }\n            } else {\n              mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);\n              `;\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n                `;\n              }\n            }\n            mainLoop += `}`;\n          }\n        }\n        if (c < filterWidth) {\n          mainLoop += `\n            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);\n            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);\n          `;\n          if (c + 1 < filterWidth) {\n            mainLoop += `\n              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);\n              wR${r}C${c + 1} =\n                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;\n          }\n        }\n      }\n    }\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;\n      }\n    }\n    let activationSnippet = '',\n      applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyReluAlpha) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n      applyActivationSnippet = `result = activation(result);`;\n    }\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    if (hasLeakyReluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${mainLoop}\n\n        vec4 result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}","map":{"version":3,"names":["util","DepthwiseConvPacked2DProgram","constructor","convInfo","addBias","activation","hasPreluActivation","hasLeakyReluAlpha","variableNames","packedInputs","packedOutput","outputShape","outShape","xNumRows","inHeight","xNumCols","inWidth","padTop","padInfo","top","padLeft","left","strideHeight","strideWidth","dilationHeight","dilationWidth","filterHeight","filterWidth","texelsAcross","mainLoop","r","c","texelC","nextTexelOffset","nearestLargerEven","activationSnippet","applyActivationSnippet","addBiasSnippet","push","userCode"],"sources":["C:\\Users\\reddy\\Documents\\Projects\\Engagement Tracker\\engagement-tracker-react\\node_modules\\@tensorflow\\tfjs-backend-webgl\\src\\conv_packed_gpu_depthwise.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUProgram} from './gpgpu_math';\n\nexport class DepthwiseConvPacked2DProgram implements GPGPUProgram {\n  variableNames = ['x', 'W'];\n  packedInputs = true;\n  packedOutput = true;\n  outputShape: number[];\n  userCode: string;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: string = null, hasPreluActivation = false,\n      hasLeakyReluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n\n    const xNumRows = convInfo.inHeight;\n    const xNumCols = convInfo.inWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const filterHeight = convInfo.filterHeight;\n    const filterWidth = convInfo.filterWidth;\n    const texelsAcross = filterWidth;\n\n    let mainLoop = `int xR; int xC; int xCOffset;`;\n\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `\n          vec4 xTexelR${r}C${c * 2} = vec4(0.);\n          vec4 wR${r}C${c} = vec4(0.);\n          vec4 xR${r}C${c} = vec4(0.);`;\n      }\n    }\n\n    /**\n     * This vectorized implementation works by gathering the values needed for\n     * each output channel's dot product into vec4's and then multiplying them\n     * all together (this happens in the final double for-loop below). Most of\n     * the main loop consists of constructing these vec4's with the minimum\n     * number of texture2D calls, which means making use of all four returned\n     * values from a texture2D call at once.\n     */\n    for (let r = 0; r < filterHeight; r++) {\n      for (let texelC = 0; texelC < texelsAcross; texelC++) {\n        const c = texelC * 2;\n\n        mainLoop += `\n          xR = xRCorner + ${r * dilationHeight};\n          xC = xCCorner + ${c * dilationWidth};\n        `;\n\n        if (strideWidth === 1) {\n          if (c < filterWidth) {\n            // If padding is odd, the outer texels have to be composed.\n            if (padLeft % 2 === 1) {\n              // TODO: Ensure vec4 previous does not result in redundant sample,\n              // and avoid setting xTexelRC's that exceed the boundary in the\n              // first place rather than resetting them to vec4(0)).\n\n              // To compute xCOffset:\n              // - If padding is odd, we must add 1 to ensure we ask for an\n              // even-numbered row.\n              // - We subtract 2 to access the previous texel.\n\n              mainLoop += `\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${\n                  xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    xTexelR${r}C${c}.zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ${xNumRows} && xCOffset >= 0 && xCOffset < ${\n                  xNumCols}) {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ${xNumCols}) {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR${r}C${c} = vec4(previous.zw, xTexelR${r}C${c}.xy);\n                } else {\n                  xR${r}C${c} = vec4(0, 0, xTexelR${r}C${c}.xy);\n                }\n              `;\n            } else {\n              // Padding is even, so xRC corresponds to a single texel.\n              mainLoop += `\n                if(xR >= 0 && xR < ${xNumRows} && xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xR${r}C${c} = xTexelR${r}C${c};\n              `;\n            }\n\n            if (c + 1 < filterWidth) {\n              // If dilation is even, the second entry should match the first\n              // (either both are composed or both are single samples). But if\n              // dilation is odd, then the second entry should be the opposite\n              // of the first (if the first is composed, the second is a single\n              // sample, and vice versa.)\n\n              const nextTexelOffset = padLeft % 2 === 0 ?\n                  util.nearestLargerEven(dilationWidth) :\n                  dilationWidth;\n\n              if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                  (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n                `;\n\n                // If dilation > 1 then the xRC's will not be able to share any\n                // values, so each xRC will require two unique calls to getX.\n                if (dilationWidth > 1) {\n                  mainLoop += `\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ${xNumRows} &&\n                      xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                      xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR${r}C${c} = vec4(0.);\n                    }\n                  `;\n                }\n\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.xy);\n                `;\n              } else {\n                mainLoop += `\n                  xCOffset = xC + ${nextTexelOffset};\n\n                  if(xR >= 0 && xR < ${xNumRows} &&\n                    xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR${r}C${c + 1} = xTexelR${r}C${c + 2};\n                `;\n              }\n            }\n          }\n        } else {  // stride > 1\n          if (c < filterWidth) {\n            mainLoop += `\n              if(xR >= 0 && xR < ${xNumRows}) {\n            `;\n\n            // Depending on whether padLeft is even or odd, we want either the\n            // xy or zw channels from X texels for xR${r}C${c}. If padLeft is\n            // even, xR${r}C${c + 1} is simply the zw channels of texels we've\n            // already sampled. But if padLeft is odd, xR${r}C{$c + 1}.zw will\n            // need to come from the xy channels of a new texel, hence the `vec4\n            // final` initialized below.\n            if (padLeft % 2 === 1) {\n              mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR${r}C${c + 1} = vec4(xTexelR${r}C${c + 2}.xy, final.xy);\n                `;\n              }\n            } else {\n              mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols}) {\n                  xTexelR${r}C${c} = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR${r}C${c} = vec4(0.);\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                  xTexelR${r}C${c + 2} = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR${r}C${c + 2} = vec4(0.);\n                }\n\n                xR${r}C${c} = vec4(\n                  xTexelR${r}C${c}.xy, xTexelR${r}C${c + 2}.xy);\n              `;\n\n              if (c + 1 < filterWidth) {\n                mainLoop += `\n                  xR${r}C${c + 1} = vec4(\n                    xTexelR${r}C${c}.zw, xTexelR${r}C${c + 2}.zw);\n                `;\n              }\n            }\n\n            mainLoop += `}`;\n          }\n        }\n\n        if (c < filterWidth) {\n          mainLoop += `\n            vec4 wTexelR${r}C${c} = getW(${r}, ${c}, d1, q);\n            wR${r}C${c} = vec4(wTexelR${r}C${c}.xz, wTexelR${r}C${c}.xz);\n          `;\n\n          if (c + 1 < filterWidth) {\n            mainLoop += `\n              vec4 wTexelR${r}C${c + 1} = getW(${r}, ${c + 1}, d1, q);\n              wR${r}C${c + 1} =\n                vec4(wTexelR${r}C${c + 1}.xz, wTexelR${r}C${c + 1}.xz);`;\n          }\n        }\n      }\n    }\n\n    for (let r = 0; r < filterHeight; r++) {\n      for (let c = 0; c < filterWidth; c++) {\n        mainLoop += `dotProd += xR${r}C${c} * wR${r}C${c};`;\n      }\n    }\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (activation) {\n      if (hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n      } else if (hasLeakyReluAlpha) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n      } else {\n        activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n      }\n\n      applyActivationSnippet = `result = activation(result);`;\n    }\n\n    const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    if (hasLeakyReluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ${mainLoop}\n\n        vec4 result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}