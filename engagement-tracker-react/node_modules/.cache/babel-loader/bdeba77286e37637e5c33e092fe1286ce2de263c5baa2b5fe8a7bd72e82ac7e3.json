{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport * as shader_compiler from './shader_compiler';\nexport function compileProgram(gpgpu, program, inputs, output) {\n  const userCode = program.userCode;\n  const inputInfos = inputs.map((input, i) => {\n    const shapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n    if (input.texData != null && input.texData.slice != null && input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n    return {\n      name: program.variableNames[i],\n      shapeInfo\n    };\n  });\n  const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n  const outShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  const source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);\n  const webGLProgram = gpgpu.createProgram(source);\n  // Add special uniforms (NAN, INFINITY)\n  let infLoc = null;\n  const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  }\n  // Add user-defined uniforms\n  const uniformLocations = {};\n  for (let i = 0; i < program.variableNames.length; i++) {\n    const varName = program.variableNames[i];\n    const shouldThrow = false;\n    uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n  }\n  return {\n    program,\n    source,\n    webGLProgram,\n    uniformLocations,\n    inShapeInfos,\n    outShapeInfo,\n    infLoc,\n    nanLoc\n  };\n}\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` + `was executed with ${inputs.length} inputs`);\n  }\n  shapeInfos.forEach((s, i) => {\n    const shapeA = s.logicalShape;\n    const input = inputs[i];\n    const shapeB = input.shape;\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(`Binary was compiled with different shapes than ` + `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n    }\n    // The input is uploaded as uniform.\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n    const texShapeA = s.texShape;\n    const texShapeB = input.isUniform ? null : input.texData.texShape;\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(`Binary was compiled with different texture shapes than the` + ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n    }\n  });\n}\nexport function runProgram(gpgpu, binary, inputs, output, customSetup) {\n  validateBinaryAndProgram(binary.inShapeInfos, inputs);\n  validateBinaryAndProgram([binary.outShapeInfo], [output]);\n  const outTex = output.texData.texture;\n  const outTexShape = output.texData.texShape;\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  }\n  gpgpu.setProgram(binary.webGLProgram);\n  // Set special uniforms (NAN, INFINITY)\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  }\n  // Set user-defined inputs\n  inputs.forEach((input, i) => {\n    const varName = binary.program.variableNames[i];\n    const varLoc = binary.uniformLocations[varName];\n    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        let vals = input.uniformValues;\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n      return;\n    }\n    // If the input was sliced, upload the flat offset index.\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n    gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n  });\n  if (customSetup != null) {\n    customSetup(gpgpu, binary.webGLProgram);\n  }\n  gpgpu.executeProgram();\n}\nexport function makeShaderKey(program, inputs, output) {\n  let keyInputs = '';\n  inputs.concat(output).forEach(x => {\n    const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0;\n    const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n    keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n  });\n  const keyUserCode = program.userCode;\n  let key = program.constructor.name;\n  // Fast string concat. See https://jsperf.com/string-concatenation/14.\n  key += '_' + keyInputs + '_' + keyUserCode;\n  return key;\n}","map":{"version":3,"names":["env","util","shader_compiler","compileProgram","gpgpu","program","inputs","output","userCode","inputInfos","map","input","i","shapeInfo","logicalShape","shape","texShape","isUniform","texData","isPacked","flatOffset","slice","name","variableNames","inShapeInfos","x","outShapeInfo","source","makeShader","packedInputs","webGLProgram","createProgram","infLoc","nanLoc","getUniformLocation","getNumber","uniformLocations","length","varName","shouldThrow","validateBinaryAndProgram","shapeInfos","Error","forEach","s","shapeA","shapeB","arraysEqual","texShapeA","texShapeB","runProgram","binary","customSetup","outTex","texture","outTexShape","setOutputPackedMatrixTexture","setOutputMatrixTexture","setProgram","gl","uniform1f","Infinity","NaN","varLoc","varOffsetLoc","sizeFromShape","uniformValues","vals","Float32Array","uniform1fv","uniform1i","setInputMatrixTexture","executeProgram","makeShaderKey","keyInputs","concat","hasOffset","keyUserCode","key","constructor"],"sources":["C:\\Users\\reddy\\Documents\\Projects\\engagement-tracker-react\\node_modules\\@tensorflow\\tfjs-backend-webgl\\src\\gpgpu_math.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, Tensor, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {GPGPUContext} from './gpgpu_context';\nimport * as shader_compiler from './shader_compiler';\nimport {InputInfo, ShapeInfo} from './shader_compiler';\nimport {PackingScheme, TextureData, TextureUsage} from './tex_util';\n\nexport interface GPGPUProgram {\n  variableNames: string[];\n  outputShape: number[];\n  userCode: string;\n  /** If true, this program expects packed input textures. Defaults to false. */\n  packedInputs?: boolean;\n  /** If true, this program produces a packed texture. Defaults to false. */\n  packedOutput?: boolean;\n  /**\n   * Affects what type of texture we allocate for the output. Defaults to\n   * `TextureUsage.RENDER`.\n   */\n  outTexUsage?: TextureUsage;\n  /**\n   * The type of scheme to use when packing texels for the output values.\n   * See `PackingScheme` for details. Defaults to `PackingScheme.SHARED_BATCH`.\n   */\n  outPackingScheme?: PackingScheme;\n}\n\nexport interface GPGPUBinary {\n  webGLProgram: WebGLProgram;\n  program: GPGPUProgram;\n  uniformLocations: {[name: string]: WebGLUniformLocation};\n  source: string;\n  inShapeInfos: ShapeInfo[];\n  outShapeInfo: ShapeInfo;\n  infLoc: WebGLUniformLocation;\n  nanLoc: WebGLUniformLocation;\n}\n\nexport interface TensorData {\n  shape: number[];\n  texData: TextureData;\n  isUniform: boolean;\n  // Available when we decide to upload as uniform instead of texture.\n  uniformValues?: TypedArray;\n}\n\nexport function compileProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, program: GPGPUProgram, inputs: TensorData[],\n    output: TensorData): GPGPUBinary {\n  const userCode = program.userCode;\n  const inputInfos: InputInfo[] = inputs.map((input, i) => {\n    const shapeInfo: ShapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n    if (input.texData != null && input.texData.slice != null &&\n        input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n    return {name: program.variableNames[i], shapeInfo};\n  });\n  const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n  const outShapeInfo: ShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  const source = shader_compiler.makeShader(\n      inputInfos, outShapeInfo, userCode, program.packedInputs);\n\n  const webGLProgram = gpgpu.createProgram(source);\n\n  // Add special uniforms (NAN, INFINITY)\n  let infLoc: WebGLUniformLocation = null;\n  const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  }\n\n  // Add user-defined uniforms\n  const uniformLocations: {[name: string]: WebGLUniformLocation} = {};\n  for (let i = 0; i < program.variableNames.length; i++) {\n    const varName = program.variableNames[i];\n    const shouldThrow = false;\n    uniformLocations[varName] =\n        gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[`offset${varName}`] =\n        gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n  }\n\n  return {\n    program,\n    source,\n    webGLProgram,\n    uniformLocations,\n    inShapeInfos,\n    outShapeInfo,\n    infLoc,\n    nanLoc,\n  };\n}\n\nfunction validateBinaryAndProgram(\n    shapeInfos: ShapeInfo[], inputs: TensorData[]) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(\n        `Binary was compiled with ${shapeInfos.length} inputs, but ` +\n        `was executed with ${inputs.length} inputs`);\n  }\n\n  shapeInfos.forEach((s, i) => {\n    const shapeA = s.logicalShape;\n    const input = inputs[i];\n    const shapeB = input.shape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(\n          `Binary was compiled with different shapes than ` +\n          `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n    }\n    // The input is uploaded as uniform.\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n\n    const texShapeA = s.texShape;\n    const texShapeB = input.isUniform ? null : input.texData.texShape;\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(\n          `Binary was compiled with different texture shapes than the` +\n          ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n    }\n  });\n}\n\nexport function runProgram<T extends Tensor, K extends Tensor>(\n    gpgpu: GPGPUContext, binary: GPGPUBinary, inputs: TensorData[],\n    output: TensorData,\n    customSetup?: (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) =>\n        void): void {\n  validateBinaryAndProgram(binary.inShapeInfos, inputs);\n  validateBinaryAndProgram([binary.outShapeInfo], [output]);\n\n  const outTex = output.texData.texture;\n  const outTexShape = output.texData.texShape;\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  }\n  gpgpu.setProgram(binary.webGLProgram);\n\n  // Set special uniforms (NAN, INFINITY)\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  }\n\n  // Set user-defined inputs\n  inputs.forEach((input, i) => {\n    const varName = binary.program.variableNames[i];\n    const varLoc = binary.uniformLocations[varName];\n    const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        let vals = input.uniformValues;\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n      return;\n    }\n\n    // If the input was sliced, upload the flat offset index.\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n\n    gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n  });\n\n  if (customSetup != null) {\n    customSetup(gpgpu, binary.webGLProgram);\n  }\n  gpgpu.executeProgram();\n}\n\nexport function makeShaderKey(\n    program: GPGPUProgram, inputs: TensorData[], output: TensorData): string {\n  let keyInputs = '';\n  inputs.concat(output).forEach(x => {\n    const hasOffset = x.texData != null && x.texData.slice != null &&\n        x.texData.slice.flatOffset > 0;\n    const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n    keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n  });\n  const keyUserCode = program.userCode;\n  let key = program.constructor.name;\n  // Fast string concat. See https://jsperf.com/string-concatenation/14.\n  key += '_' + keyInputs + '_' + keyUserCode;\n  return key;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}