{"ast":null,"code":"import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n  constructor(shape, exclusive, reverse) {\n    this.variableNames = ['x'];\n    this.outputShape = shape;\n    const rank = shape.length;\n    const val = exclusive ? '0.0' : \"getX(\".concat(getCoords(rank, 'coords'), \")\");\n    const length = shape[shape.length - 1];\n    let condition = '';\n    let idxString = '';\n    // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n    if (exclusive) {\n      condition = reverse ? \"end != \".concat(length - 1) : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? \"end + pow2 < \".concat(length) : 'end >= pow2';\n      idxString = reverse ? 'end + pow2' : 'end - pow2';\n    }\n    this.userCode = \"\\n      uniform float index;\\n      void main() {\\n        \".concat(getCoordsDataType(rank), \" coords = getOutputCoords();\\n        int end = \").concat(getFinalCoord(rank, 'coords'), \";\\n        float val = \").concat(val, \";\\n        int pow2 = int(pow(2.0, index));\\n        if (\").concat(condition, \") {\\n          int idx = \").concat(idxString, \";\\n          \").concat(getFinalCoord(rank, 'coords'), \" = idx;\\n          val += getX(\").concat(getCoords(rank, 'coords'), \");\\n        }\\n        setOutput(val);\\n      }\\n    \");\n  }\n  getCustomSetupFunc(index) {\n    return (gpgpu, webGLProgram) => {\n      if (this.index == null) {\n        this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n      }\n      gpgpu.gl.uniform1f(this.index, index);\n    };\n  }\n}\nfunction getCoords(rank, name) {\n  if (rank === 1) {\n    return \"\".concat(name);\n  } else if (rank === 2) {\n    return \"\".concat(name, \".x, \").concat(name, \".y\");\n  } else if (rank === 3) {\n    return \"\".concat(name, \".x, \").concat(name, \".y, \").concat(name, \".z\");\n  } else if (rank === 4) {\n    return \"\".concat(name, \".x, \").concat(name, \".y, \").concat(name, \".z, \").concat(name, \".w\");\n  } else {\n    throw Error(\"Cumulative sum for rank \".concat(rank, \" is not yet supported\"));\n  }\n}\nfunction getFinalCoord(rank, name) {\n  if (rank === 1) {\n    return \"\".concat(name);\n  } else if (rank === 2) {\n    return \"\".concat(name, \".y\");\n  } else if (rank === 3) {\n    return \"\".concat(name, \".z\");\n  } else if (rank === 4) {\n    return \"\".concat(name, \".w\");\n  } else {\n    throw Error(\"Cumulative sum for rank \".concat(rank, \" is not yet supported\"));\n  }\n}","map":{"version":3,"names":["getCoordsDataType","CumSumProgram","constructor","shape","exclusive","reverse","variableNames","outputShape","rank","length","val","concat","getCoords","condition","idxString","userCode","getFinalCoord","getCustomSetupFunc","index","gpgpu","webGLProgram","getUniformLocation","gl","uniform1f","name","Error"],"sources":["C:\\Users\\reddy\\Documents\\Projects\\engagement-tracker-react\\node_modules\\@tensorflow\\tfjs-backend-webgl\\src\\cumsum_gpu.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUContext} from './gpgpu_context';\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class CumSumProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n\n  // Caching uniform location for speed.\n  index: WebGLUniformLocation;\n\n  constructor(shape: number[], exclusive: boolean, reverse: boolean) {\n    this.outputShape = shape;\n    const rank = shape.length;\n    const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n    const length = shape[shape.length - 1];\n    let condition = '';\n    let idxString = '';\n    // When exclusive is set, the cumsum op becomes roll op that copies the\n    // value from the previous index based on the direction specified by the\n    // reverse flag.\n    if (exclusive) {\n      condition = reverse ? `end != ${length - 1}` : 'end != 0';\n      idxString = reverse ? 'end + 1' : 'end - 1';\n    } else {\n      condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n      idxString = (reverse ? 'end + pow2' : 'end - pow2');\n    }\n\n    this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n  }\n\n  getCustomSetupFunc(index: number) {\n    return (gpgpu: GPGPUContext, webGLProgram: WebGLProgram) => {\n      if (this.index == null) {\n        this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n      }\n      gpgpu.gl.uniform1f(this.index, index);\n    };\n  }\n}\n\nfunction getCoords(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.x, ${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.x, ${name}.y, ${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n\nfunction getFinalCoord(rank: number, name: string): string {\n  if (rank === 1) {\n    return `${name}`;\n  } else if (rank === 2) {\n    return `${name}.y`;\n  } else if (rank === 3) {\n    return `${name}.z`;\n  } else if (rank === 4) {\n    return `${name}.w`;\n  } else {\n    throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n  }\n}\n"],"mappings":"AAkBA,SAAQA,iBAAiB,QAAO,mBAAmB;AAEnD,OAAM,MAAOC,aAAa;EAQxBC,YAAYC,KAAe,EAAEC,SAAkB,EAAEC,OAAgB;IAPjE,KAAAC,aAAa,GAAG,CAAC,GAAG,CAAC;IAQnB,IAAI,CAACC,WAAW,GAAGJ,KAAK;IACxB,MAAMK,IAAI,GAAGL,KAAK,CAACM,MAAM;IACzB,MAAMC,GAAG,GAAGN,SAAS,GAAG,KAAK,WAAAO,MAAA,CAAWC,SAAS,CAACJ,IAAI,EAAE,QAAQ,CAAC,MAAG;IACpE,MAAMC,MAAM,GAAGN,KAAK,CAACA,KAAK,CAACM,MAAM,GAAG,CAAC,CAAC;IACtC,IAAII,SAAS,GAAG,EAAE;IAClB,IAAIC,SAAS,GAAG,EAAE;IAClB;IACA;IACA;IACA,IAAIV,SAAS,EAAE;MACbS,SAAS,GAAGR,OAAO,aAAAM,MAAA,CAAaF,MAAM,GAAG,CAAC,IAAK,UAAU;MACzDK,SAAS,GAAGT,OAAO,GAAG,SAAS,GAAG,SAAS;KAC5C,MAAM;MACLQ,SAAS,GAAGR,OAAO,mBAAAM,MAAA,CAAmBF,MAAM,IAAK,aAAa;MAC9DK,SAAS,GAAIT,OAAO,GAAG,YAAY,GAAG,YAAa;;IAGrD,IAAI,CAACU,QAAQ,iEAAAJ,MAAA,CAGPX,iBAAiB,CAACQ,IAAI,CAAC,sDAAAG,MAAA,CACbK,aAAa,CAACR,IAAI,EAAE,QAAQ,CAAC,6BAAAG,MAAA,CAC3BD,GAAG,+DAAAC,MAAA,CAEXE,SAAS,+BAAAF,MAAA,CACDG,SAAS,mBAAAH,MAAA,CACnBK,aAAa,CAACR,IAAI,EAAE,QAAQ,CAAC,qCAAAG,MAAA,CACjBC,SAAS,CAACJ,IAAI,EAAE,QAAQ,CAAC,0DAI5C;EACH;EAEAS,kBAAkBA,CAACC,KAAa;IAC9B,OAAO,CAACC,KAAmB,EAAEC,YAA0B,KAAI;MACzD,IAAI,IAAI,CAACF,KAAK,IAAI,IAAI,EAAE;QACtB,IAAI,CAACA,KAAK,GAAGC,KAAK,CAACE,kBAAkB,CAACD,YAAY,EAAE,OAAO,CAAC;;MAE9DD,KAAK,CAACG,EAAE,CAACC,SAAS,CAAC,IAAI,CAACL,KAAK,EAAEA,KAAK,CAAC;IACvC,CAAC;EACH;;AAGF,SAASN,SAASA,CAACJ,IAAY,EAAEgB,IAAY;EAC3C,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACd,UAAAG,MAAA,CAAUa,IAAI;GACf,MAAM,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACrB,UAAAG,MAAA,CAAUa,IAAI,UAAAb,MAAA,CAAOa,IAAI;GAC1B,MAAM,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACrB,UAAAG,MAAA,CAAUa,IAAI,UAAAb,MAAA,CAAOa,IAAI,UAAAb,MAAA,CAAOa,IAAI;GACrC,MAAM,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACrB,UAAAG,MAAA,CAAUa,IAAI,UAAAb,MAAA,CAAOa,IAAI,UAAAb,MAAA,CAAOa,IAAI,UAAAb,MAAA,CAAOa,IAAI;GAChD,MAAM;IACL,MAAMC,KAAK,4BAAAd,MAAA,CAA4BH,IAAI,0BAAuB,CAAC;;AAEvE;AAEA,SAASQ,aAAaA,CAACR,IAAY,EAAEgB,IAAY;EAC/C,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACd,UAAAG,MAAA,CAAUa,IAAI;GACf,MAAM,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACrB,UAAAG,MAAA,CAAUa,IAAI;GACf,MAAM,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACrB,UAAAG,MAAA,CAAUa,IAAI;GACf,MAAM,IAAIhB,IAAI,KAAK,CAAC,EAAE;IACrB,UAAAG,MAAA,CAAUa,IAAI;GACf,MAAM;IACL,MAAMC,KAAK,4BAAAd,MAAA,CAA4BH,IAAI,0BAAuB,CAAC;;AAEvE"},"metadata":{},"sourceType":"module","externalDependencies":[]}