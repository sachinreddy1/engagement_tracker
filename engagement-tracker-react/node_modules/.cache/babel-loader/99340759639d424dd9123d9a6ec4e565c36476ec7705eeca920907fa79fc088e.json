{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n  const inputRank = input.shape.length;\n  util.assert(inputRank === begin.length, () => \"Error in slice\".concat(inputRank, \"D: Length of begin \").concat(begin, \" must \") + \"match the rank of the array (\".concat(inputRank, \").\"));\n  util.assert(inputRank === size.length, () => \"Error in slice\".concat(inputRank, \"D: Length of size \").concat(size, \" must \") + \"match the rank of the array (\".concat(inputRank, \").\"));\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(begin[i] + size[i] <= input.shape[i], () => \"Error in slice\".concat(inputRank, \"D: begin[\").concat(i, \"] + size[\").concat(i, \"] \") + \"(\".concat(begin[i] + size[i], \") would overflow input.shape[\").concat(i, \"] (\").concat(input.shape[i], \")\"));\n  }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n  const axes = [];\n  let axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n  const size = [];\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n  const newStrides = [...strides];\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n  return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n  const elidedAxes = [];\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n    normalizedEnd = new Array(inputRank),\n    normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0];\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n  let stride = strides[axis];\n  if (ellipsisMask & 1 << axis || stride == null) {\n    stride = 1;\n  }\n  return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1;\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n  return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1;\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n  return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function computeFlatOffset(begin, strides) {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n  // The following logic allows for more ergonomic calls.\n  let begin_;\n  const xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_;\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(d === -1, () => \"Negative size values should be exactly -1 but got \" + \"\".concat(d, \" for the slice() size at index \").concat(i, \".\"));\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n  // make a copy because it may be modified further down.\n  let $begin = begin.slice();\n  let $end = end.slice();\n  let $strides = strides;\n  if (strides == null) {\n    $strides = new Array($begin.length);\n  }\n  const ellipsisAxes = maskToAxes(ellipsisMask);\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n  const numInterpolatedAxes = xShape.length - $begin.length;\n  // Expand the dims of x based on the newAxisMask.\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = xShape.slice();\n  expandAxes.forEach(axis => {\n    $begin[axis] = 0;\n    $end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n  const {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);\n  $begin = normalizedBegin;\n  $end = normalizedEnd;\n  $strides = normalizedStrides;\n  const shrinkAxes = maskToAxes(shrinkAxisMask);\n  // Adjust the ends based on the shrink mask.\n  shrinkAxes.forEach(axis => {\n    $end[axis] = $begin[axis] + 1;\n    $strides[axis] = 1;\n  });\n  // Figure out the output shape.\n  const size = computeOutShape($begin, $end, $strides);\n  // Remove the axes based on shrinkMask.\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n  const nonStrided = $strides.every(v => v === 1);\n  return {\n    nonStrided,\n    $begin,\n    $end,\n    $strides,\n    size,\n    newShape,\n    outShape\n  };\n}","map":{"version":3,"names":["util","assertParamsValid","input","begin","size","inputRank","shape","length","assert","concat","i","maskToAxes","mask","axes","axis","push","computeOutShape","end","strides","Math","ceil","stridesWithElidedDims","ellipsisInsertionIndex","numElidedAxes","inputShape","newStrides","splice","pop","unnormalizeAxis","normalizedAxis","getElidedAxes","elidedAxes","getNormalizedAxes","ellipsisAxes","numInterpolatedAxes","beginMask","endMask","ellipsisMask","normalizedBegin","Array","normalizedEnd","normalizedStrides","fullIndex","startIndicesWithElidedDims","stopIndicesWithElidedDims","startForAxis","stopForAxis","stridesForAxis","originalBegin","newIndices","indexOf","originalAxis","originalValue","originalEnd","Number","MAX_SAFE_INTEGER","axisSize","clamp","stride","startIndices","start","MIN_SAFE_INTEGER","stopIndices","stop","isSliceContinous","firstNonOneAxis","computeFlatOffset","flatOffset","parseSliceParams","x","begin_","xRank","fill","slice","forEach","d","size_","map","sliceInfo","xShape","newAxisMask","shrinkAxisMask","$begin","$end","$strides","Error","expandAxes","newShape","shrinkAxes","outShape","filter","_","nonStrided","every","v"],"sources":["C:\\Users\\reddy\\Documents\\Projects\\Engagement Tracker\\engagement-tracker-react\\node_modules\\@tensorflow\\tfjs-core\\src\\ops\\slice_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '../kernel_registry';\nimport * as util from '../util';\n\nexport type SliceInfo = {\n  nonStrided: boolean,\n  $begin: number[],\n  $end: number[],\n  $strides: number[],\n  size: number[],\n  newShape: number[],\n  outShape: number[]\n};\n\nexport function assertParamsValid(\n    input: TensorInfo, begin: number[], size: number[]): void {\n  const inputRank = input.shape.length;\n  util.assert(\n      inputRank === begin.length,\n      () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n          `match the rank of the array (${inputRank}).`);\n  util.assert(\n      inputRank === size.length,\n      () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n          `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(\n        begin[i] + size[i] <= input.shape[i],\n        () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${\n                  input.shape[i]})`);\n  }\n}\n\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask: number): number[] {\n  const axes = [];\n  let axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(\n    begin: number[], end: number[], strides: number[]): number[] {\n  const size = [];\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(\n    strides: number[], ellipsisInsertionIndex: number, numElidedAxes: number,\n    inputShape: number[]): number[] {\n  const newStrides = [...strides];\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(\n          ellipsisInsertionIndex, 0 /* num elements to delete */,\n          1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\n\nfunction unnormalizeAxis(\n    ellipsisInsertionIndex: number, numElidedAxes: number,\n    normalizedAxis: number): number {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes: number, ellipsisInsertionIndex: number) {\n  const elidedAxes = [];\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(\n    inputShape: number[], ellipsisAxes: number[], numInterpolatedAxes: number,\n    begin: number[], end: number[], strides: number[], beginMask: number,\n    endMask: number,\n    ellipsisMask: number): {begin: number[], end: number[], strides: number[]} {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0];\n\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(\n        beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(\n        endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides =\n        stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(\n          beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] =\n          stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(\n    beginMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalBegin: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(\n    endMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalEnd: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\n\nexport function stridesForAxis(\n    strides: number[], axis: number, ellipsisMask: number): number {\n  let stride = strides[axis];\n  if (ellipsisMask & (1 << axis) || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\n\nexport function startForAxis(\n    beginMask: number, startIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n\n  return start;\n}\n\nexport function stopForAxis(\n    endMask: number, stopIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(\n    shape: number[], begin: number[], size: number[]) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function computeFlatOffset(begin: number[], strides: number[]): number {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\n\nexport function parseSliceParams(\n    x: TensorInfo, begin: number|number[], size?: number|number[]) {\n  // The following logic allows for more ergonomic calls.\n  let begin_: number[];\n  const xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(\n        d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_: number[];\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(\n          d === -1,\n          () => `Negative size values should be exactly -1 but got ` +\n              `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\n\nexport function sliceInfo(\n    xShape: number[], begin: number[], end: number[], strides: number[],\n    beginMask: number, endMask: number, ellipsisMask: number,\n    newAxisMask: number, shrinkAxisMask: number): SliceInfo {\n  // make a copy because it may be modified further down.\n  let $begin = begin.slice();\n  let $end = end.slice();\n  let $strides = strides;\n\n  if (strides == null) {\n    $strides = new Array($begin.length);\n  }\n\n  const ellipsisAxes = maskToAxes(ellipsisMask);\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error(\n        'Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error(\n        'Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n\n  const numInterpolatedAxes = xShape.length - $begin.length;\n\n  // Expand the dims of x based on the newAxisMask.\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = xShape.slice();\n  expandAxes.forEach(axis => {\n    $begin[axis] = 0;\n    $end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n\n  const {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  } =\n      getNormalizedAxes(\n          newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides,\n          beginMask, endMask, ellipsisMask);\n  $begin = normalizedBegin;\n  $end = normalizedEnd;\n  $strides = normalizedStrides;\n\n  const shrinkAxes = maskToAxes(shrinkAxisMask);\n  // Adjust the ends based on the shrink mask.\n  shrinkAxes.forEach(axis => {\n    $end[axis] = $begin[axis] + 1;\n    $strides[axis] = 1;\n  });\n\n  // Figure out the output shape.\n  const size = computeOutShape($begin, $end, $strides);\n  // Remove the axes based on shrinkMask.\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n\n  const nonStrided = $strides.every(v => v === 1);\n\n  return {nonStrided, $begin, $end, $strides, size, newShape, outShape};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}